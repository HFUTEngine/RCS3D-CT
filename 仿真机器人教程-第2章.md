# 第二章 仿真足球系统(30页)

讲解3D仿真的基本要求、系统原理、主流仿真系统、ROBOCUP中三种底层

## 诸论

​	仿真是机器人学习和研究过程中最重要的工具之一，是指通过计算机对实际的物理系统进行模拟的技术。机器人仿真基于交互式计算机图形技术和机器人学理论，生成机器人的几何图形，并对其进行三维显示，用来描述机器人及工作环境的动态变化过程。本章将介绍机器人仿真的工作原理和主要流程，了解主流的机器人仿真平台。介绍RoboCup仿真3D所使用的仿真平台以及工作流程，并对目前该比赛中主要采用的三种球队底层代码进行介绍。

## 2.1机器人仿真的工作原理

​	机器人仿真是推进机器人系统开发和部署的关键，为系统和环境建模提供了极大的便利。它们有助于在虚拟空间中对机器人的机械结构、电子系统和软件执行详细的设计和分析，使开发人员可以在不带来现实风险的情况下识别设计缺陷并优化性能。仿真包括：

- 系统建模：仿真用于创建和分析机器人系统的设计，有助于理解在虚拟环境中进行系统建模时的组件交互。这可以优化系统性能，确保产品功能符合预期。
- 环境建模：环境建模可对机器人操作时所处的物理世界进行仿真，通过各种设置测试导航和任务执行。这种安全、高效的方法可以在各种条件下测试机器人，而不需要真实世界的测试成本。
- 虚拟调试：它在虚拟环境中验证机器人的控制策略和系统集成，从而减少停机时间，提高系统运行时的效率。

机器人仿真可以分为若干种类型，每种类型在机器人系统的开发和测试中都服务于特定用途：

- 多域动态仿真：基于力和扭矩等物理特性，用于在真实条件下测试控制系统，以设计与其环境进行物理交互的机器人。使用基于物理的多域建模工具，您可以执行多体动态仿真，并微调机械组件、作动器和控制策略，以确保实现有效且高效的操作。
- 运动学运动仿真：用于可视化机器人的运动，确保路径无碰撞且高效。它们对于规划和验证机器人轨迹以设计自主系统应用至关重要。在这种仿真中，您可以对机器人的 AI 和决策能力进行建模，仿真它们如何感知和响应虚拟环境，这对于自主操作来说是必不可少的。
- 高级任务仿真：用于评估机器人执行复杂任务的能力，帮助验证机器人在特定场景下操作的有效性。高级任务仿真利用了游戏引擎的高级物理和渲染功能，并结合了传感器和场景仿真，用于仿真机器人在复杂动态环境中的输入和输出。
- 硬件在环 (HIL) 仿真：将包括可编程逻辑控制器 (PLC) 在内的真实硬件组件纳入仿真中，支持实时测试和验证工业控制系统。HIL 仿真便于执行高度精确且高效的测试过程。这种方法至关重要，它使您能够在物理部署之前识别潜在问题、优化系统性能和确保可靠性。

<img src="D:\RoboCup\图片\2.1.jpg" alt="2.1" style="zoom:50%;" />

​	虚拟仿真软件能够在虚拟的计算机环境中，对现实的物理环境进行仿真，并且这种仿真效果具有一定的逼真度。在机器人学领域中，机器人仿真技术发挥着重要的作用,它能够给机器人的研究开发提供一个安全可靠的平台。一般来说,机器人仿真软件可以通过三维建模创建虚拟环境中的机器人及其工作环境，而不依赖于实际的机器人,而且它还可以提供多种不同的机器人仿真应用。在某些情况下，这些仿真软件中的程序可以通过直接转移或重建到实际的机器人。使用机器人仿真软件开发机器人控制程序有许多好处，仿真软件允许人们在将程序写入到真实的机器人之前，多次地测试与调试。

一般的机器人仿真平台主要包括以下四个方面的功能：

①便于设计和创建机器人模型，使用软件自身或者外部工具对需要的机器人进行合理的建模；

②使用物理引擎仿真机器人在现实中的运动过程，例如ODE物理引擎(注重高性能计算和实时性)、Vortex物理引擎(商业物理引擎，注重仿真计算精度)；

③对仿真环境进行渲染，便于用户实时观察仿真过程，对仿真过程进行控制；

④使用脚本语言对机器人进行运动仿真，例如支持C语言、python、MATLAB等主流语言，对运动过程进行控制。

## 2.2主流机器人仿真系统

目前存在着多种科研或者商业仿真系统，包括开源与不开源，都有着各自的特点，各自所针对的领域与特点也各不相同。一个机器仿真系统的开发流程和成本是十分巨大的，要实现对现实机器人的验证或者参考作用，对仿真系统的要求较为严格。评判一个仿真系统的指标有很多，这里只对主流的几个机器人仿真软件进行介绍，下面是对不同机器人仿真软件的对比：

![2.2](D:\RoboCup\图片\2.2.png)

​	机器人仿真软件的选用需要从物理逼真度(物理环境的条件、特征逼近真实环境的程度)、功能逼真度(软件仿真进行时机器人的行为逼近实际情况中机器人执行任务的程度)、编程语言及扩展性、平台支持、费用成本和开发成本等多方面去选择。

### 仿真系统

**V-REP仿真系统：**

V-REP（现在更新命名为CoppeliaSim）是免费的，用于教育目的，如果计划将其用于商业项目，则可以升级到专业版。可以在Windows，Linux或macOS上运行V-REP，并且可以使用六种不同的编程语言对其进行编程。它还具有ROS＆BlueZero支持，因此可以只使用3D模拟器并使代码在另一个平台上运行。

V-REP支持四种不同的物理引擎（Bullet, ODE, Newton, and Vortex Dynamics）。它可以准确地处理对象的交互，例如碰撞，接触点和抓取。V-REP还支持粒子物理学来模拟空气和水，因此可以准确地对喷气发动机和螺旋桨建模。V-REP还可以模拟各种传感器，甚至可以通过插件将新传感器添加到模拟器。V-REP甚至支持路径和运动规划，甚至可以计算正向和逆向运动学。它还支持网格编辑，因此可以在模拟器中对设计进行小的调整，或者可以轻松导入任何五种不同3D模型格式（obj，STL，URDF等）的模型。

<img src="D:\RoboCup\图片\2.3.png" alt="2.3" style="zoom:50%;" />

**Gazebo仿真系统：**

Gazebo模拟器是一个免费的开源平台，可用于设计，开发，测试和可视化几乎任何类型的机器人。Gazebo可在Linux，Windows和Mac上运行，是ROS的默认仿真器，可以调用多种开源算法并可以直接部署到真机。Gazebo支持多种高性能物理引擎，例如ODE，Bullet，Simbody和DART。Gazebo模拟器还附带了一些机器人模型，例如PR2，DX，Irobot Create和TurtleBot，因此即使没有自己的机器人模型，也可以快速上手。它还支持广泛的传感器，并且可以模拟噪声和传感器故障，以准确模拟实际问题。甚至可以在云中运行Gazebo，并使用简单的Web浏览器与模拟器进行交互。

Gazebo中的模型格式是基于XML的SDF，构建一个模型需要用户自己编写XML文件，对于初学者有一定难度。其次，Gazebo对于闭链结构机器人的支持不够完善，并且Gazebo与ROS的结合程度很高，对于不熟悉ROS的用户而言上手难度较大。

<img src="D:\RoboCup\图片\2.4.png" alt="2.4" style="zoom:50%;" />

**SimSpark仿真系统：**

SimSpark 是一种通用的物理多代理模拟器系统，适用于三维环境中的代理。它基于灵活的Spark应用程序框架构建，被用作官方的RoboCup3D模拟服务器，也是本教程主要介绍的仿真系统。与专用模拟器相比，用户可以使用场景描述语言创建新的模拟，因此SimSpark 是进行不同多智能体研究问题的强大工具。

SimSpark 是作为RoboCup计划的一部分开发的，最初称为机器人世界杯计划。这是一项国际研究和教育计划，它希望通过提供一个标准问题来促进人工智能和智能机器人研究，其中可以集成和检查各种技术，并用于以项目为导向的综合教育。为此，RoboCup官方组织了竞技性的 RoboCup比赛。其中仿真模拟联赛是整个足球比赛在模拟环境中进行的几个联赛之一。SimSpark 的早期版本是将球员和球建模为平坦的球体，但它缺乏进一步逼真的物理环境。在 RoboCup 2004 中，SimSpark成功用于RoboCup仿真3D联赛的首次官方比赛。本次比赛的足球模拟与 SimSpark 模拟器并行开发。在这个版本中，玩家被建模为物理三维世界中的球体。从这时起，SimSpark 有了稳定的发展，现在该模拟器已经支持具有关节身体的人形机器人。目前已经支持多种主流机器人模型，例如比赛官方指定的软银的Nao人形机器人。虽然SimSpark一直为RoboCup足球联赛进行开发与维护，但并未为其进行特定的优化，其依然具有通用模拟器的功能。

<img src="D:\RoboCup\图片\2.5.png" alt="2.5" style="zoom: 80%;" />

在此之上，为便于RoboCup仿真3D的比赛，官方在SimSpark基础之上，针对该联赛开发了官方比赛软件RCSSServer3D。它实现了一个足球比赛模拟，一场比赛10分钟，由两支不同的球队进行对抗，每支队伍由最多 11 个人形机器人组成。这种设置与现实足球比赛的配置相同，并且需遵守一定的比赛规则，否则会受到相应的惩罚。一般来说，球员违反规则会由服务器自动执行惩罚，但程序无法包括所有情景，因此比赛过程中也需要人工裁判实时关注比赛，并进行合理的判决。

### 物理引擎

物理引擎是一种计算机软件，用于在计算机图形学、视频游戏和电影等领域中模拟某些物理系统的近似行为。这些系统包括刚体动力学（包括碰撞检测）、软体动力学和流体动力学。物理引擎的主要用途是在视频游戏中实现实时仿真，通常作为中间件集成到游戏引擎中。此外，该术语有时也用于描述用于仿真物理现象的任何软件系统，例如高性能科学仿真。

​	物理引擎通常分为两类：高精度物理引擎和实时物理引擎。

1. **高精度物理引擎**：

   高精度物理引擎需要大量的处理能力来计算非常精确的物理模型。这类引擎通常被科学家和计算机动画电影使用，以确保物理现象的高精度和逼真度。

2. **实时物理引擎**：

   实时物理引擎主要用于视频游戏和其他形式的交互式计算。为了在有限的时间内完成计算并保持游戏的流畅性，实时物理引擎通常采用简化的计算方法和较低的精度。这样可以确保游戏在各种硬件上都能以适当的速度运行，并及时响应玩家的输入。

​	在机器人仿真中，物理引擎起着至关重要的作用，它负责模拟真实世界的物理现象，使得机器人在虚拟环境中能够表现出接近真实的行为。物理引擎能够模拟刚体的动力学行为，包括物体的运动、旋转、加速度和力的传递。这对于仿真机器人的关节运动、抓取物体、行走和移动等行为至关重要。通过刚体动力学仿真，可以准确预测机器人在不同条件下的运动轨迹和姿态。物理引擎能够检测物体之间的碰撞，并计算相应的碰撞响应。这对于机器人在复杂环境中的导航和避障非常重要。碰撞检测可以防止机器人与其他物体发生不必要的碰撞，确保其安全运行。物理引擎支持实时仿真，即仿真过程与实际时间同步。这对于测试实时控制系统非常重要，可以确保机器人在仿真中的行为与真实环境中的表现一致。物理引擎提供了一个安全的测试平台，可以在不涉及实际风险的情况下进行极限测试和故障模拟。这对于确保机器人在各种工况下的安全性和可靠性非常重要。

**Open Dynamics Engine(ODE)**

​	ODE 是一个用于模拟刚体动力学的开源高性能库。它功能齐全、稳定、成熟且独立于平台，并具有易于使用的 C/C++ API。它具有先进的关节类型和集成的摩擦碰撞检测。ODE 对于模拟虚拟现实环境中的车辆、物体和虚拟生物非常有用。目前它被用于许多计算机游戏、3D 创作工具和模拟工具中，也是SimSpark所使用的物理引擎。ODE非常适合模拟铰接刚体结构，对机器人仿真此类问题有很大优势，在设计时便用于交互式或实时仿真，适合在快速多变的环境中移动物体，这也是SimSpark使用该引擎的原因之一。

**PhysX**

​	PhysX 是一款用于计算机图形和仿真应用程序的物理引擎，由 NVIDIA 公司开发和维护。它能够模拟和计算物体之间的真实物理行为，如重力、摩擦、碰撞等，并将其应用于游戏、虚拟现实、电影特效等领域。PhysX 提供了一套完整的物理模拟工具包，支持刚体动力学、软体模拟、流体模拟以及碰撞检测等特性。它的核心是高效的多线程处理和硬件加速功能，尤其在 NVIDIA GPU 上能展现出卓越的性能。

**Simbody**

​	Simbody 可用于内部坐标和粗粒度分子建模,大型机械模型如骨骼,以及任何其他可以建模为通过关节互连,由力作用和受约束限制的任何东西。Simbody 是一个SimTK 工具集,提供通用多体动力学能力,即在任意约束的任何一组广义坐标中解决牛顿第二定津(F=ma)的能力。Simbody 作为一个开源、面向对象的 C++ API提供的物理引擎,它能够用于高性能、精度控制的科学工程。因此,它适用于大型机械模型,如人类步态、机器人、化身和动画的神经肌肉模型。Simbody 也可以用于实时交互式应用程序的生物仿制以及虚拟世界和游戏。

**Bullet**

​	Bullet 是一个完全开源的物理引擎，使用 zlib 许可证，适合学术研究和商业项目。支持 Windows、Linux、macOS、Android 和 iOS 等多个平台。Bullet 的代码库相对较小，易于集成和扩展。支持刚体动力学、软体动力学、流体动力学、布料模拟等。并且拥有一个活跃的开发者社区，提供丰富的资源和文档。

## 2.3 RoboCup仿真3D系统介绍

### 2.3.1 RCSSServer3D比赛环境基本信息

RCSSServer3D是RoboCup仿真3D比赛的官方比赛环境，基于SimSpark仿真软件上二次开发。在每年举办RoboCup比赛前，官方根据各球队的建议和比赛过程中发现的问题进行更新和维护，发布在本届比赛中所采用的SimSpark版本和对应的RCSSServer3D版本。2024年RoboCup世界杯中仿真3D比赛所采用的版本为SimSpark 0.3.6和RCSSServer3D 0.7.7，比赛所使用电脑环境为Ubuntu 24.04。

<img src="D:\RoboCup\图片\2.7.png" alt="2.7" style="zoom:50%;" />

目前仿真比赛中所使用的机器人模型为软银的Nao机器人（之前采用的是Soccerbot），在比赛过程中服务器会执行一个自动规则集，该规则集包含现实足球比赛中基本的规则。但是对于检测不公平行为等复杂情况，仍然需要人类裁判通过监视器进行人工干预。同时每年世界杯根据具体情况还会制定特殊的规则，并在比赛前发布，内容各有所不同。

**RCSSServer3D仿真球场的相关信息：**

<img src="D:\RoboCup\图片\2.6.png" alt="2.6" style="zoom: 25%;" />

足球场大小为30米×20米，两边的球门长2.1米，宽0.6米，高0.8米，罚球区为3.9米×1.8米，中心圆半径为2米（在仿真过程中该圆是以十边形代替），足球的半径为0.04米，质量为26克。在足球场外，该区域被10米的边界包围，因此机器人无法到达该边界之外，从而限制机器人的总体空间。现实中一个标准的FIFA足球场大约是110米×70米，因此仿真足球的场地大约是全尺寸球场的35%。

除此之外，为便于机器人的定位，在足球场的四个角落和球门柱上，有一个特殊的标记。在仿真过程中该标志的位置固定，机器人可以通过感知这些标志中与自身的相对位置以及所能感知到的场线（例如中心圆的场线）信息进行定位。角旗的标记放置在地平面（0.0米），球门柱标记放置在每个球门柱的顶部，高度为0.8米。

**自动判罚规则：**

为了进行一场足球比赛，必须遵守特定的规则。自动裁判会自动限制每半场比赛的时间，它进一步跟踪哪个球员是最后一个触球的球员，并检查球是否进入足球场的球门禁区，或者是否被踢进了禁区。因此，它能够检测是否进球，自动判断球是否出界并判决边界球、角球或者球门球给正确的球队。越位规则已经实施，但仍处于试验阶段。在任意球中，对手必须保持1.3米的最小距离，如果是球门球，则必须保持1.0米的最小距离。

随着最新版本的足球模拟几个新的规则被应用到自动裁判，以确保顺利的游戏。自动裁判试图避免球周围的机器人的大规模碰撞，以及机器人故意躺在球场上，阻止游戏。此外，它还注意到没有一支球队会用超过一定数量的球员来阻止自己的进球。在所有情况下，造成问题的机器人都会自动被传送到足球场外。有关所有参数，可以参考*rcssserver3d*文件夹中的*naosoccersim.rb*。

**人类判罚规则：**

人类裁判通过连接的监视器进行操作，在每场比赛的半场负责发出开球命令。自动判罚目前不能解决游戏卡住的情况，例如几个球员互相阻挡，造成没有机器人能够接触到球，同时它也不会检测足球场上使用手或其他不当行为等犯规行为。在这些情况下，人类裁判可以将球丢到足球场上，即将球放在比赛场地上的随机位置以解决这种情景，也可以放置任意球，使得其中一名球员能够从很短的距离射门。

RoboCup世界杯每年举行一次，地点每年都会改变，并且全年中有几个区域公开赛，如德国公开赛，荷兰公开赛，伊朗公开赛，日本公开赛和中国公开赛，些比赛吸引了最多的参赛者，使其成为一次难忘的体验！

### 2.3.2 RCSSServer3D比赛环境的安装

SimSpark和RCSSServer3D支持Linux、Windows和MacOS系统，目前官方比赛一般采用Linux系统。因此，在日常使用和开发过程中建议采用Linux系统。在各种Linux发行版中，比赛官方通常采用最新版本的Ubuntu发行版。本教程以Ubuntu24.04发行版为例，介绍相关软件的安装操作。

关于Ubuntu的运行环境，最为推荐的是在一台物理机上运行，SimSpark和RCSSServer3D的仿真过程需要进行大量的计算，对于硬件资源需求较大，在开发过程中同时需要多种开发软件，因此一台物理机是最适合运行比赛的。除此之外，也可以采用Linux虚拟机或者windows子系统来进行Ubuntu系统的安装。相关系统的安装过程不在此赘述，读者可自行查阅相关资料。

- **通过软件源安装**

安装simspark和rcssserver3d的最简单方法是使用openSUSE Build Service上的SimSpark存储库，通过添加软件源可以直接使用Linux软件包管理命令进行安装与更新。在终端中输入如下命令：

```bash
echo 'deb http://download.opensuse.org/repositories/science:/SimSpark/xUbuntu_24.04/ /' | sudo tee /etc/apt/sources.list.d/science:SimSpark.list
curl -fsSL https://download.opensuse.org/repositories/science:SimSpark/xUbuntu_24.04/Release.key | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/science_SimSpark.gpg > /dev/null
sudo apt-get update
sudo apt-get install rcssserver3d
```

等待安装完成便可以启动RCSSServer3D比赛环境。

在官方发布新版本的SimSpark和RCSSServer3D软件，可以使用如下命令进行更新：

```bash
sudo apt-get update && sudo apt-get install rcssserver3d 
```

- **通过源代码构建(推荐)**

通过软件源安装是安装比赛环境最简单的方式，但另一种更推荐的方式是采用SimSpark存储库的源代码进行编译，在Ubuntu发行版中，安装如下步骤进行安装。

1. 启用Universe和Multiverse存储库：

   ```bash
   sudo add-apt-repository universe
   sudo add-apt-repository multiverse
   sudo apt update
   ```

2.  安装相应的依赖库：

   对于Ubuntu24.04：

   ```bash
   sudo apt-get install g++ git make cmake libfreetype6-dev libode-dev libsdl2-dev ruby ruby-dev libdevil-dev libboost-dev libboost-thread-dev libboost-regex-dev libboost-system-dev qtbase5-dev qtchooser qt5-qmake libqt5opengl5-dev
   ```

   对于Ubuntu22.04：

   ```bash
   sudo apt-get install g++ git make cmake libfreetype6-dev libode-dev libsdl2-dev ruby ruby-dev libdevil-dev libboost-dev libboost-thread-dev libboost-regex-dev libboost-system-dev qtbase5-dev qtchooser qt5-qmake libqt5opengl5-dev
   ```

   对于Ubuntu20.04：

   ```bash
   sudo apt-get install g++ git make cmake libfreetype6-dev libode-dev libsdl2-dev ruby ruby-dev libdevil-dev libboost-dev libboost-thread-dev libboost-regex-dev libboost-system-dev qt5-default libqt5opengl5-dev
   ```

   对于Ubuntu18.04：

   ```bash
   sudo apt-get install g++ git make cmake libfreetype6-dev libode-dev libsdl-dev ruby ruby-dev libdevil-dev libboost-dev libboost-thread-dev libboost-regex-dev libboost-system-dev qt5-default
   ```

3.  下载最新的simspark和rcssserver3d包，如果想使用Git仓库中的最新代码，可从Gitlab仓库中查看源代码：

   ```bash
   git clone https://gitlab.com/robocup-sim/SimSpark.git 
   ```

4. 配置软件包，生成构建文件并安装软件包：

   ```bash
   cd SimSpark
   bash build.sh
   ```

5. 安装与测试：

   启动模拟器：

   ```bash
   simspark #或 rcssserver3d
   ```

   运行测试：

   ```bash
   rcssagent3d
   ```

经过上述步骤，便完成了RCSSServer3D比赛软件的安装。

### 2.3.3 仿真软件的使用

安装RCSSServer3D仿真软件后，可通过相关命令启动仿真软件，并通过监视器观察球场状态。

1. 启动球场服务器：

在终端中输入：

```bash
simspark #或 rcssserver3d
```

可以看到如下输出：

![2.8](D:\RoboCup\图片\2.8.png)

在输出信息中可以获取服务器的相关信息，例如仿真软件的版本0.7.7，作者姓名，使用帮助等。

2. 启动球场监视器：

在终端中输入：

```bash
rcssmonitor3d
```

可以看到如下输出：

![2.9](D:\RoboCup\图片\2.9.png)

并会弹出如下的监视器窗口：

![2.10](D:\RoboCup\图片\2.10.png)

rcssmonitor3d是仿真软件中的一个外部监视软件，负责渲染当前模拟。它连接到一个正在运行的服务器实例，并从该实例持续接收更新流，这些更新流将模拟状态描述为完整快照或增量更新。服务器发送到监视器的数据流的格式称为监视器格式，它是一种用于描述仿真状态的可定制语言。除了描述纯模拟状态之外，每个监视器格式可以提供传输附加游戏特定状态的机制。对于仿真足球比赛，这些机制包括当前比赛的模式和当前比赛双方的比分。监视器客户端本身只渲染纯场景，并将游戏状态的渲染推迟到插件。这些插件用来解析游戏状态并将其显示为叠加，例如在屏幕上打印出播放模式和分数。除此之外，监视器还可以回放记录文件。

监视器通过按键或鼠标接受许多控制命令，这些命令可以控制摄像机的移动，也可以将命令发送回服务器以控制模拟。仿真足球比赛使用这些命令来实现对人类裁判的控制。例如：A、W、S、D按键控制视角的前后左右移动，鼠标右键控制视角上升，按下滚轮控制视角下降。具体使用方法可在[Monitor · Wiki · RoboCup Simulation / SimSpark · GitLab](https://gitlab.com/robocup-sim/SimSpark/-/wikis/Monitor)中查看。

3. 运行测试代理：

在终端中输入：

```bash
rcssagent3d
```

可以看到如下输出：

![2.11](D:\RoboCup\图片\2.11.png)

该命令启动一个机器人实例，与服务器进行通信，并对收到的信息进行解析。以下是有关输出的相关代码：

```cpp
if (sender == "self")
    {
        cout << "I said " << message << " at " << heartime << endl;

    } else {
        cout << "Someone "
             << (abs(atof(sender.c_str()))<90?"in front of":"behind")
             << " me said " << message << " at " << heartime << endl;
    }
```

在新终端中再次运行该命令，可以看到如下输出：

![2.12](D:\RoboCup\图片\2.12.png)

可以看到，输出中出现了更多信息，代表目前仿真环境中有两个agent代理正在运行，并且一个机器人在另一个机器人的侧边90度的位置。

在监视器中移动视角，可以看到球场中出现两个机器人，位置符合一个机器人在另一个机器人的侧边90度的位置：

![2.13](D:\RoboCup\图片\2.13.png)

新建终端可以继续运行上述命令，将会出现更多机器人，请注意同一个队伍的相同类型机器人的数量不能超过一定的数目，具体规则将在后续章节给出。

在终端中输入：

```bash
which simspark
```

可以在环境变量中查找到simspark的路径，在该路径下还存在着有关仿真软件的其他工具，其中可以看到，simspark已经链接到rcssserver3d，所以在该仿真环境下simspark与rcssserver3d是等效的。rcsoccersim3d可以同时打开服务器与监视器，即相当于同时运行rcssserver3d与rcssmonitor3d。sparkgui是基于spark仿真软件的图形化界面控制软件，在此不再详细介绍。

![2.14](D:\RoboCup\图片\2.14.png)

## 2.4 RCSSServer3D比赛环境的相关概念

本章节针对SimSpark中的相关概念进行介绍，包括感知器、效应器、智能体、机器人模型以及网络消息交互等，仿真环境与智能体的交互消息符合S表达式标准，主要包括服务器与智能体、智能体与服务器以及服务器与监视器三个方面的信息交互，该部分对理解仿真流程和后续开发相当重要。

### 2.4.1感知器

感知器是智能体的感官，是智能体感知机器人模型自身状态和仿真环境的方式。服务器通过网络协议在模拟的每个周期中向智能体发送感知器的消息。每种消息类型的详细信息显示在下面的每个部分中，其中既有适用于所有仿真过程的通用感知器，也有特用于足球仿真比赛的足球感知器。

#### 1.1通用感知器

本小节中描述的感知器可用于所有类型的模拟，也就是说，它们并不特定于足球环境。

##### 1.1.1陀螺仪速率感知器

陀螺仪速率感知器提供有关物体方向变化的信息。该消息包含 GYR 标识符、陀螺仪感知器所属的身体名称和三个旋转角度。这些旋转角度描述了上一个周期中物体方向的变化率。换句话说，沿相应物体的三个自由轴的当前角速度，以度/秒为单位。为了跟踪身体的方向，每个周期都会向每个陀螺仪速率感知器发送信息。Nao机器人的上本身有一个陀螺仪感知器。

| 消息格式   | (GYR  (n <name>)  (rt  <x> <y> <z>))                         |
| :--------- | :----------------------------------------------------------- |
| <name>     | 陀螺仪速率感知器附加到的身体部位的名称。                     |
| <x><y><z>  | 沿相应物体的三个自由轴的当前角速度，以度/秒为单位。          |
| 示例消息： | (GYR (n torso) (rt 0.01 0.07 0.46))                          |
| 频率       | 每个周期                                                     |
| 噪音模式   | 没有。但是，值被截断为两位小数，相当于最大 0.01 度的统一误差。 |

##### 1.1.2铰链关节感知器

![2.15](D:\RoboCup\图片\2.15.png)

铰链关节感知器接收有关相应单轴铰链关节角度的信息。它包含标识符 HJ、感知器的名称和轴的位置角度（以度为单位）。零角度对应于直线对齐的实体。每个铰链关节感知器的位置角度在每个周期发送一次。每个铰链关节对其角度位置都有最小和最大限制。这因铰链而异，并取决于所使用的型号。Nao机器人包含22个铰链关节感知器，曾经使用的Soccerbot包含8个铰链关节感知器。

| 消息格式 | (HJ (n <name>) (ax <ax>))                                |
| :------- | :------------------------------------------------------- |
| <name>   | 相应铰链铰接的名称。                                     |
| <ax>     | 当前位置角度（以度为单位）。                             |
| 示例消息 | (HJ (n laj3) (ax -1.02))                                 |
| 频率     | 每个周期                                                 |
| 噪音模型 | 无，但值被截断为两位小数，相当于最大 0.01 度的统一误差。 |

与此感知器所对应的是铰链关节效应器。

##### 1.1.3万向关节感知器

![](D:\RoboCup\图片\2.16.png)

万向节感知器接收有关相应的两轴万向节的两个角度的信息。它包含标识符 UJ、感知器的名称和两个轴的位置角度。零度对应于直线对齐的实体。Nao机器人没有万向节，曾经使用的Soccerbot有6个万向节。

| 消息格式    | (UJ (n <name>) (ax1 <ax1>) (ax2 <ax2>))                  |
| ----------- | -------------------------------------------------------- |
| <name>      | 相应万向节的名称                                         |
| <ax1>,<ax2> | 两个轴的当前位置角度（以度为单位）。                     |
| 示例消息    | (UJ (n laj1 2) (ax1 -1.32) (ax2 2.00))                   |
| 频率        | 每个周期                                                 |
| 噪音模型    | 无，但值被截断为两位小数，相当于最大 0.01 度的统一误差。 |

与此感知器对应的是万向关节效应器。

##### 1.1.4触摸感知器

此感知器的工作方式类似于缓冲器，如果它所装载的代理部件与另一个模拟对象发生碰撞，则会触发该缓冲器。感知器始终报告自己的唯一名称。这允许每个代理使用多个 TouchPerceptor。此外，还给出了值 0 表示未检测到冲突，或给出值 1 表示检测到冲突。此感知器目前未在 rcssserver3d 中的任何机器人模型中使用。

| 消息格式 | (TCH n <name> val <bit>) |
| -------- | ------------------------ |
| 示例消息 | (TCH n bumper val 1)     |

##### 1.1.5阻力感知器

这个感知器告知作用在物体上的力。在标识符 FRP 和正文名称之后，感知器消息包含两个向量。第一个向量描述相对于物体本身的原点，第二个向量描述该点上的合力。这两个矢量只是关于实际施加的力的近似值。原点计算为施加力的所有接触点的加权平均值，而力矢量表示施加到所有这些接触点的总力。向阻力感知器发送信息，以防相应物体与另一个模拟对象发生碰撞。如果未施加力，则省略此感知器的消息。

Nao和Soccerbot 都有两个这样的感知器，位于每只脚的底部，标记为 *lf* 和 *rf*。

| 消息格式     | (FRP (n <name>) (c <px> <py> <pz>) (f <fx> <fy> <fz>))       |
| ------------ | ------------------------------------------------------------ |
| <name>       | 阻力感知器所属的物体的名称。                                 |
| <px><py><pz> | 所施加力原点的局部坐标（以米为单位）。                       |
| <fx><fy><fz> | 力矢量的分量，力矢量的长度表示以牛顿 （kg m/s2） 为单位的给定力。 |
| 示例消息     | (FRP (n lf) (c -0.14 0.08 -0.05) (f 1.12 -0.26 13.07))       |
| 频率         | 每个周期，但仅限于当前碰撞的情况下。                         |
| 噪音模型     | 无，但值被截断到小数点后两位，相当于高达 0.01 米/牛顿的均匀误差。 |

##### 1.1.6加速度计

此感知器测量它相对于自由落体所经历的适当加速度。因此，相对于地球表面静止的加速度计将指示大约 1g （9.81m/s^2） 以上。为了获得相对于地球的运动引起的加速度，应减去该重力偏移。Nao机器人的上半身有一个加速度计。

| 消息格式  | (ACC (n <name>) (a <x> <y> <z>))                             |
| --------- | ------------------------------------------------------------ |
| <name>    | 包含加速度计的主体的名称。                                   |
| <x><y><z> | 沿相应物体的三个自由轴的当前加速度，单位为 m/s2。            |
| 示例消息  | (ACC (n torso) (a 0.00 0.00 9.81))                           |
| 频率      | 每个周期                                                     |
| 噪音模型  | 无，但值被截断为小数点后两位，相当于高达 0.01 m/s2 的统一误差。 |

#### 1.2足球感知器

以下感知器是特定于足球的，仅在足球模拟中可用。请记住，虽然 SimSpark 主要由RoboCup 3D 模拟联盟使用，但它是一个通用模拟器，适用于其他用途，RCSSServer3d 为以下感知器提供支持。

##### 1.2.1视觉感知器

视觉感知器提供有关环境中所见对象的信息，其中对象是其他球员、球、场地线或球场上的标记。目前球场上有 8 个标记：球场的每个角点一个，每个球门柱一个。对于每个可见对象，您将获得一个以球坐标描述的向量。换句话说，相对于照相机方向，到可见物体中心的距离以及水平角和纬度角。

![](D:\RoboCup\图片\2.17.png)

与 2D 足球模拟不同，视觉系统不提供物体速度。所有距离和角度都是相对于相机的位置和方向给出的。此时，对象不会被其他对象遮挡，尽管这可能会在将来实现。

视觉系统的噪声参数如下：

- 相机位置会增加一个小的校准误差。对于每个轴，误差均匀分布在 ±0.005m 之间。该误差计算一次，并在代理的生命周期内保持不变（请注意，新的竞争规则涉及服务器在中场休息时重新启动，这将重新计算此校准误差）。
- 对于以下各项，动态噪声呈正态分布在 0.0 左右：
  - 距离误差：σ2 = 0.0965（此外，距离误差乘以距离/100）
  - 水平角（φ）误差：σ2 = 0.1225
  - 垂直角 （θ） 误差：σ2 = 0.1480

视觉消息以 See 开头，后跟已看到对象的列表。虽然球场上的球和标记是仅通过一个位置向量描述的简单对象，但球员是一个更复杂的对象，需要更严格的描述以及 teamname 等附加信息。因此，通过球队名称、球员编号和不同身体部位的一个或多个位置向量来描述球员。除此之外，场线被认为是两个位置向量（“起点”和“终点”），以受限的视觉为界。与字段上的标记不同，字段行不使用标识符进行标记。在较旧的服务器版本中，玩家也只用一个位置向量来描述。在这种情况下，发送给玩家的消息格式仅包含一个指向上半身中心的位置向量，而不包含任何其他身体部位信息。此外，字段行在较旧的服务器版本（低于 6.4）中不可见。请注意，并非每个模拟周期都会报告来自视觉感知器的数据。截至 2012 年 5 月，它们每 3 个周期（0.06 秒）报告一次。

| 消息格式   | (See +(<name> (pol <distance> <angle1> <angle2>))     +(P (team <teamname>) (id <playerID>) +(<bodypart> (pol <distance> <angle1> <angle2>)))     +(L (pol <distance> <angle1> <angle2>) (pol <distance> <angle1> <angle2>))) |
| ---------- | ------------------------------------------------------------ |
| <name>     | 简单对象的名称，如下表：简单的可见对象                       |
| <distance> | 到看到的对象的距离。                                         |
| <angle1>   | 与可见对象相对于视图方向的水平角度 （φ），以度为单位，精度为两位数。正角位于代理视觉垂直中线的左侧，负角位于右侧。 |
| <angle2>   | 与可见物体相对于视图方向的垂直角度 （θ），以度为单位，精度为两位数。正角度表示看到的物体高于智能体视野的水平中线，负角度表示低于。 |
| <teamname> | 所看到的玩家所属的团队的名称。                               |
| <playerID> | 看到的玩家的玩家编号。                                       |
| <bodypart> | 身体部分的名称                                               |
| 示例消息   | (See (G2R (pol 17.55 -3.33 4.31))     (G1R (pol 17.52 3.27 4.07))     (F1R (pol 18.52 18.94 1.54))     (F2R (pol 18.52 -18.91 1.52))     (B (pol 8.51 -0.21 -0.17))     (P (team teamRed) (id 1)        (head (pol 16.98 -0.21 3.19))        (rlowerarm (pol 16.83 -0.06 2.80))        (llowerarm (pol 16.86 -0.36 3.10))        (rfoot (pol 17.00 0.29 1.68))        (lfoot (pol 16.95 -0.51 1.32)))     (P (team teamBlue) (id 3)        (rlowerarm (pol 0.18 -33.55 -20.16))        (llowerarm (pol 0.18 34.29 -19.80)))     (L (pol 12.11 -40.77 -2.40) (pol 12.95 -37.76 -2.41))     (L (pol 12.97 -37.56 -2.24) (pol 13.32 -32.98 -2.20))) |
| 频率       | 每 3 个周期（每 0.06 秒）                                    |
| 噪音模型   | 校准误差（每个 x/y/z 轴的固定偏移约为 ±0.004m）、高斯噪声（如上所述）和值被截断到小数点后两位，相当于高达 0.01 的统一误差。 |

简单的可见对象：

| 可见对象 | 名字               |
| -------- | ------------------ |
| 旗帜     | F1L, F1R, F2L, F2R |
| 球门门柱 | G1L, G1R, G2L,G2R  |
| 球       | B                  |

Nao 的可见身体部位:

| 可见的身体部位  | 标识      |
| --------------- | --------- |
| Head            | head      |
| Right lower arm | rlowerarm |
| Left lower arm  | llowerarm |
| Right foot      | rfoot     |
| Left foot       | lfoot     |

Nao机器人的头部中央有一个受限的视觉感知器，该感知器将视野限制为120度，这是目前默认的视觉感知器（在早期的版本为360度的全景视觉）。

##### 1.2.2比赛状态感知器

比赛状态感知器提供有关足球比赛环境实际状态的多个信息。游戏状态消息以 *GS* 标识符开头，后跟不同状态信息的列表。目前，球队的比分、实际比赛时间和比赛模式在每个周期中传输。游戏时间从上半场开球时的 0 开始，到下半场开始时的 300 开始，以浮点数（以秒为单位）精确到小数点后两位。具体的比赛状态可在下文查阅。

| 消息格式   | (GS (sl <sl>) (sr <sr>) (t <time>) (pm <playmode>)) |
| ---------- | --------------------------------------------------- |
| <sl>       | 左边队伍的得分                                      |
| <sr>       | 右边队伍的得分                                      |
| <time>     | 当前比赛的时间（以秒为单位）                        |
| <playmode> | 足球比赛的当前比赛模式                              |
| 示例消息   | (GS (sl 1) (sr 2) (t 0.00) (pm BeforeKickOff))      |
| 频率       | 每个周期                                            |

在未来的足球版本中，模拟可能会扩展此感知器提供的数据，以最初包括比赛变量，例如球的重量和场地大小，尽管要求代理自行推断环境的这些属性似乎同样有效。

##### 1.2.3智能体状态感知器

智能体状态感知器提供有关代理内部状态的信息。它报告有关当前电池状态和代理温度的信息，但目前智能体的电池和温度并未影响比赛，或许在未来的版本将发挥作用。

| 消息格式 | (AgentState (temp <degree>) (battery <percentile>)) |
| -------- | --------------------------------------------------- |
| 示例消息 | (AgentState (temp 48) (battery 75))                 |

##### 1.2.4听觉感知器

智能体进程不允许直接相互通信，但代理可以通过模拟服务器交换消息。为此，代理配备了所谓的听觉感知器，它用作听觉传感器并接收其他玩家喊出的信息。实际上，底层模型源于 2D 足球模拟，并且从服务器版本 0.4 开始就已集成到 3D 模拟器中。

| 消息格式    | (hear <team> <time> self/<direction> <message>)              |
| ----------- | ------------------------------------------------------------ |
| <team>      | 发出消息的玩家的团队                                         |
| <time>      | 听到给定消息的模拟时间，以秒为单位（实数）                   |
| <direction> | 以度为单位的相对水平方向表示声音的来源，或者 self 表示玩家正在听到自己的单词 |
| <message>   | 最多 20 个字符，可以从 ASCII 打印字符子集 *[0x20， 0x7E]* 中获取，但空格字符和普通括号除外 |
| 示例消息    | (hear MyTeam 12.3 self helloyourself) (hear OpponentTeam 12.3 -12.7 helloworld) |
| 频率        | 详见下面的听觉限制                                           |

**听觉限制**

听觉感知器有一些限制：

- 消息被限制为最大长度（当前为 20 字节）。
- 消息只能由 ASCII 子集 *[0x20; 0x7E]* 中的字符组成，不包括空格字符[0x20]，括号字符 *[0x28，0x29]* ，也就是!"#$%&'*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~一共92个字符。
- 从最大距离（当前 50 米）之外喊出的信息无法听到。请注意，由于场地目前只有 20x30 米（对角线 36 米），这在实践中并不是一个限制。
- 可以同时听到的消息数是有界的。每个玩家的最大容量是每两个模拟周期听到一个特定团队的消息（因此每个团队每 0.04 秒）。两支球队都有单独跟踪的能力，因为球队不应该能够通过永久喊叫来阻止对手的听觉感知器。如果团队成员在两个模拟周期内说出多条消息，则只会听到一条消息（第一个到达服务器），其余消息将被丢弃。不过，自己喊出的信息总是会被听到。

在这些限制下，每个字节有 91 个唯一值。20 字节有 1.516456694×10^39 条唯一消息，如果仔细编码，总共大约 130 位信息。

### 2.4.2 效应器

效应器允许智能体在模拟中执行操作，智能体通过向服务器发送消息来控制它们，服务器相应地更改游戏状态。效应器器是感知器的逻辑上的对应。效应器控制消息通过网络协议发送，每种消息类型的详细信息显示在下面的每个部分中。与感知器相同，既有适用于所有模拟的通用效应器，也有特定于足球模拟的足球效应器。

#### 1.1 通用效应器

本小节中描述的效应器可用于所有类型的模拟。换句话说，它们并不特定于足球模拟。

##### 1.1.1创建效应器

当智能体最初连接到服务器时，它是不可见的，并且无法以任何有意义的方式影响模拟。它只拥有一个所谓的创建效应器。代理使用此效应器通知服务器根据它作为参数传递的场景描述文件来构造它。此文件用于构造物理表示以及所有进一步的效应器和感知器。

| 消息格式 | (scene <filename>)            |
| -------- | ----------------------------- |
| 示例消息 | (scene rsg/agent/nao/nao.rsg) |

在服务器中构建代理表示后，代理应进行进一步的模拟特定设置。例如，在足球模拟中，每个代理都需要注册到一个团队并获得一个唯一的球员编号。对于这些任务，通常会使用特殊的效应器，如下文介绍的特用于足球模拟的初始化效应器。

##### 1.1.2铰链关节效应器

![](D:\RoboCup\图片\2.18.png)

具有单个自由度的效应器，第一个参数是轴的名称，第二个参数是速度值，以每秒弧度为单位传递。在铰链上设置速度值意味着将保持速度，直到提供新值为止。即使铰链遇到其末端，它也会在末端弹跳，直到得到新的速度值。

| 消息格式 | (<name> <ax>) |
| -------- | ------------- |
| 示例消息 | (lae3 5.3)    |

Nao机器人有22个铰链关节效应器，曾经使用的Soccerbot有8个铰链关节效应器。与此效应器对应的是铰链关节感知器。

##### 1.1.3万向关节效应器

![](D:\RoboCup\图片\2.19.png)

万向关节效应器是具有两个自由度的效应器。第一个参数是轴的名称，第二个和第三个参数包含两个关节的角度变化，关节的顺序与名称中的顺序相同。

| 消息格式 | (<name> <ax1> <ax2>) |
| -------- | -------------------- |
| 示例消息 | (lae1 -2.3 1.2)      |

Nao机器人没有万向关节，曾经使用的Soccerbot有6个万向关节，与此效应器对应的是万向关节感知器。

##### 1.1.4同步效应器

在同步模式下运行的智能体必须在每个模拟周期结束时发送此命令。请注意，如果以实时模式接收到此命令，服务器将忽略此命令，因此可以安全地将代理配置为始终将此命令附加到代理的响应中。

| 消息格式 | （syn） |
| -------- | ------- |

#### 1.2 足球效应器

以下效果器是特定于足球的，仅在足球模拟中可用。请记住，虽然 SimSpark 主要由RoboCup 3D模拟联盟使用，但它是一个通用模拟器，适用于其他用途。*RCSSServer3D* 为以下效应器提供支持。

##### 1.2.1 初始化效应器

在创建效应器发送 scene 命令后，将为每个代理发送一次 init 命令。它将此代理注册为具有传递编号的已传递团队的成员。一个团队的所有玩家都必须使用相同的 `teamname` 和不同的 `playernumber` 值。如果代理发送 *0* 作为 `playernumber`，则服务器会自动将该号码分配给下一个空闲号码。球队数量上限为 2 支，目前每方最多 11 名玩家。球队开始比赛的一方取决于哪支球队先连接。请注意，`teamname` 不能包含空格。使用 *[A-Z a-z_-]*（正则表达式字符范围）是安全的。

| 消息格式 | (init (unum <playernumber>)(teamname <yourteamname>)) |
| -------- | ----------------------------------------------------- |
| 示例消息 | (init (unum 1)(teamname teamred))                     |

##### 1.2.2 定位效应器

定位效应器允许球员在每半场开始之前将自己定位在场上。`x` 和 `y` 坐标定义场相对于场坐标系的位置，其中 （0,0）是场的绝对中心。`rot` 指定玩家的朝向角度（以度为单位）。0 指向正 x 轴，90 指向正 y 轴。

| 消息格式 | (beam <x> <y> <rot>)  |
| -------- | --------------------- |
| 示例消息 | (beam 10.0 -10.0 0.0) |

##### 1.2.3 广播效应器

广播效应器允许通过广播消息在代理之间进行通信。为了说明某些内容，必须使用以下命令：

| 消息格式 | （say <message>） |
| -------- | ----------------- |
| 示例消息 | （say helloword） |

请务必阅读此效应器的对应功能，即听觉感知器，因为它详细说明了可以发送的消息内容的限制，以及在什么情况下其他智能体会实际听到您的消息。

### 2.4.3 智能体

##### 创建一个智能体

您几乎可以用无限的方式对代理进行编程。进程外代理通过 TCP 与模拟器通信，因此任何支持 TCP 套接字通信的平台上的任何语言都是代理的候选项。

要了解如何对代理进行编程，请理解上述对感知器和执行器的介绍，从而按照上述格式来创建自己的智能体。SimSpark整体的运行流程如下图所示：

![](D:\RoboCup\图片\2.20.png)

不过很明显这是一个很复杂的过程，需要大量的工作，幸运的是，目前有很多参与RoboCup比赛的队伍公开了他们的底层代码，包括了很多基础的功能以及相应的示例，相应的开源代码和历届二进制文件、日志文件可在此查看https://ssim.robocup.org/3d-simulation/3d-tools。

##### 创建足球队伍涉及的挑战

为了在竞争环境中以有意义的方式行事，第一个挑战是在竞争环境中定位您的代理。为了支持这一点，代理体感知它们与一组固定地标（如旗帜和目标）的相对位置。还可以看到其他球员和球等动态对象。

如果代理知道它在哪里以及它在不久的将来想去哪里，那么下一个挑战就是走到那里。人形模型的结构足够逼真，使这种移动性变得非同小可得，除此之外，代理还必须从跌倒中恢复过来。

另一个挑战是踢球，虽然这听起来微不足道，但对于机器人来说，在踢球和控制球的方向时保持动态平衡绝非易事。

能够移动和踢球的智能体需要合作并组成一个团队，只有有效应用战略和合作行为才能形成一个成功的团队。

### 2.4.4 机器人模型

SimSpark 附带不同的机器人模型供智能体使用。每个模型的物理表示都存储在文件中 `.rsg` 。模型的视觉方面存储在 `.obj` 和 `.mtl` 文件中。

#### **Nao**

Aldebaran Robotics 制造的 Nao 人形机器人。它的高度约为 57 厘米，体重约为 4.5 公斤。其具有 22 个自由度的 Biped 架构使 Nao 具有极好的机动性。如您所见，rcssserver3d 很好地模拟了 Nao。

![](D:\RoboCup\图片\2.21.png)

<img src="D:\RoboCup\图片\2.22.jpg" style="zoom:25%;" />

##### 1 机器人配置

<img src="D:\RoboCup\图片\2.22.png" style="zoom:50%;" />

此部分对于用于表示此机器人的特定感知器和效应器的代理开发非常重要。Nao 机器人模型配备了强大的感知器和效应器选择，为智能体开发提供广泛的信息基础。

- Nao 机器人拥有陀螺仪和加速度计，用于跟踪自身在三维空间中的径向和轴向运动。两者都位于躯干的中心，因此这些感知器唯一可用的标识符是*torso*。
- 为了检测与地面或模拟中其他物体的接触，每只脚中的一个力阻力感知器指示其上的实际压力。可用的标识符是 *lf* 和 *rf*，分别代表左脚和右脚。
- 为了获得环境中不同物体的视觉信息，Nao 机器人的头部中央有一个受限的视觉感知器。注： 视觉感知在面向 x 轴的右手系统中进行描述。
- 为了进行通信，它配备了一个广播效应器和相应的听觉感知器。
- 每个关节的位置由铰链关节感知器表示，并可通过相应的铰链关节效应器进行操纵。下表列出了 Nao 机器人的所有可用关节及其相应标识符的完整列表。关节的排列及其相对方向如上图所示。
- 比赛状态感知器用于通知实际比赛时间和比赛模式。

关节对应表：

| 序号 | 描述                 | 铰链关节   | 感知器名称 | 效应器名称 |
| ---- | -------------------- | ---------- | ---------- | ---------- |
| 1    | Neck Yaw             | 【0】【0】 | hj1        | he1        |
| 2    | Neck Pitch           | 【0】【1】 | hj2        | he2        |
| 3    | Left Shoulder Pitch  | 【1】【0】 | laj1       | lae1       |
| 4    | Left Shoulder Yaw    | 【1】【1】 | laj2       | lae2       |
| 5    | Left Arm Roll        | 【1】【2】 | laj3       | lae3       |
| 6    | Left Arm Yaw         | 【1】【3】 | laj4       | lae4       |
| 7    | Left Hip YawPitch    | 【2】【0】 | llj1       | lle1       |
| 8    | Left Hip Roll        | 【2】【1】 | llj2       | lle2       |
| 9    | Left Hip Pitch       | 【2】【2】 | llj3       | lle3       |
| 10   | Left Knee Pitch      | 【2】【3】 | llj4       | lle4       |
| 11   | Left Foot Pitch      | 【2】【4】 | llj5       | lle5       |
| 12   | Left Foot Roll       | 【2】【5】 | llj6       | lle6       |
| 13   | Right Hip YawPitch   | 【3】【0】 | rlj1       | rle1       |
| 14   | Right Hip Roll       | 【3】【1】 | rlj2       | rle2       |
| 15   | Right Hip Pitch      | 【3】【2】 | rlj3       | rle3       |
| 16   | Right Knee Pitch     | 【3】【3】 | rlj4       | rle4       |
| 17   | Right Foot Pitch     | 【3】【4】 | rlj5       | rle5       |
| 18   | Right Foot Roll      | 【3】【5】 | rlj6       | rle6       |
| 19   | Right Shoulder Pitch | 【4】【0】 | raj1       | rae1       |
| 20   | Right Shoulder Yaw   | 【4】【1】 | raj2       | rae2       |
| 21   | Right Arm Roll       | 【4】【2】 | raj3       | rae3       |
| 22   | Right Arm Yaw        | 【4】【3】 | raj4       | rae4       |

一个完整的示例消息如下：

```plaintext
(time (now 93.60))
(GS (t 0.00) (pm BeforeKickOff))
(hear 0.00 self 1000-501)
(GYR (n torso) (rt -0.35 -0.36 -0.01))
(ACC (n torso) (a 0.20 -0.20 9.79))
(HJ (n hj1) (ax 0.33))
(HJ (n hj2) (ax -3.31))
(See (G2R (pol 17.55 -3.33 4.31))
     (G1R (pol 17.52 3.27 4.07))
     (F1R (pol 18.52 18.94 1.54))
     (F2R (pol 18.52 -18.91 1.52))
     (B (pol 8.51 -0.21 -0.17))
     (P (team teamRed) (id 1)
        (head (pol 16.98 -0.21 3.19))
        (rlowerarm (pol 16.83 -0.06 2.80))
        (llowerarm (pol 16.86 -0.36 3.10))
        (rfoot (pol 17.00 0.29 1.68))
        (lfoot (pol 16.95 -0.51 1.32)))
     (P (team teamBlue) (id 1)
        (rlowerarm (pol 0.18 -33.55 -20.16))
        (llowerarm (pol 0.18 34.29 -19.80))))
(HJ (n raj1) (ax 31.72))
(HJ (n raj2) (ax -20.12))
(HJ (n raj3) (ax -0.01))
(HJ (n raj4) (ax 40.04))
(HJ (n laj1) (ax 64.37))
(HJ (n laj2) (ax 19.96))
(HJ (n laj3) (ax 0.09))
(HJ (n laj4) (ax -40.11))
(HJ (n rlj1) (ax -0.06))
(HJ (n rlj2) (ax 20.31))
(HJ (n rlj3) (ax -39.24))
(HJ (n rlj4) (ax 20.02))
(HJ (n rlj5) (ax 0.04))
(FRP (n rf) (c 0.01 -0.01 -0.02) (f -0.21 0.21 19.77))
(HJ (n rlj6) (ax 0.21))
(HJ (n llj1) (ax -0.01))
(HJ (n llj2) (ax 0.00))
(HJ (n llj3) (ax 19.70))
(HJ (n llj4) (ax -41.02))
(HJ (n llj5) (ax 20.31))
(FRP (n lf) (c 0.01 -0.01 -0.02) (f -0.21 0.20 25.45))
(HJ (n llj6) (ax -0.16))
```

![](D:\RoboCup\图片\2.22-2.png)

注意，除基础的Nao机器人模型外，rcssserver3d还包括其基础类型的变体，主要是身高和身体部位长度的不同，以及脚趾关节的增加，一共五种机器人类型。团队必须使用至少三种不同的机器人类型，任何一种机器人类型不超过七个代理，任何两种机器人类型不超过九个代理。除此之外，类型4机器人在脚部有脚趾关节，因此该类型机器人总共有24个铰链关节。以下的关节是该类型机器人独有的：

| 序号 | 描述            | 感知器名称 | 效应器名称 |
| ---- | --------------- | ---------- | ---------- |
| 1    | Left Toe Pitch  | llj7       | lle7       |
| 2    | Right Toe Pitch | rlj7       | rle7       |

##### 2 物理特性

除了感知器和效应器之外，了解用于构建机器人的参数对于智能体开发也非常重要。身体尺寸和不同身体部位的排列如下图所示：

<img src="D:\RoboCup\图片\2.23.png" style="zoom: 25%;" />

下表给出了 Nao 配置的详细描述：

![](D:\RoboCup\图片\2.24.png)

相关解释：

- **Name** 是 Nao 的身体部位名称
- **Parent** 是主体的父项
- **Transtation** 是相对于其父级的偏移量 （以毫米为单位）
- **Mass** 是这个物体的质量（以千克为单位）
- **Geometry** 是其 geometry 表示的大小（以毫米为单位）
- **Name** 是安装在此实体上的关节名称
- **Anchor** 是关节锚点相对于安装在其上的主体的偏移量（以毫米为单位）
- **Axis**是相对于安装在（轴的 x、y、z 方向）上的关节轴
- **Min** 是关节可以达到的最小角度 （以度为单位）
- **Max** 是关节可以达到的最大角度（以度为单位）

注意：所有值都是相对于 torso 坐标系的！（面向 y 轴）

##### 3 实现文件

Nao 机器人模型在以下文件中 `rcssserver3d/data/rsg/agent/nao` 下的 rsg 文件中实现。

| 文件名                           | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| box_appearance.rsg               | 安装用于 GL 渲染的框                                         |
| box_physics.rsg                  | 安装具有物理效果的长方体（ODE 相关）                         |
| box_physics_nocollider.rsg       | 安装一个只有动态效果（质量、线速度等）的盒子                 |
| box_physics_with_handler.rsg     | 不仅可以作为盒子模型执行工作，还可以在 模型节点下安装一个 触觉感知器 |
| ccylinder_appearance.rsg         | 安装用于 GL 渲染的带帽圆柱体                                 |
| ccylinder_physics.rsg            | 安装具有物理效果的带盖圆柱体（ODE 相关）                     |
| ccylinder_physics_nocollider.rsg | 安装一个仅具有动力学效果（质量、线速度等）的封闭圆柱体，使其永远不会与其他圆柱体发生碰撞 |
| contactjointhandler.rsg          | 安装关节链接来处理冲突                                       |
| dragcontroller.rsg               | 安装拖动控制器                                               |
| goal.rsg                         | 安装球门                                                     |
| hingejoint.rsg                   | 安装铰链接头                                                 |

#### Soccerbot

<img src="D:\RoboCup\图片\2.25.png" style="zoom:25%;" />

Soccerbot 是一种具有 20 个自由度 （DOF） 的人形机器人。它在 RoboCup 3D 足球模拟联赛中使用了很多年，但已被Nao取代。对于真正的人形机器人来说，它的尺寸非常不切实际，这是由于机器人首次建模时物理模拟的不稳定性。这是这种机器人模型的一个严重缺点。另一个问题是，在当前模型中，关节范围不受限制。这允许非常不切实际的动作，这些动作看起来很有趣，但可能会导致比赛中的不公平行为。Soccerbot 有几种可用的感知器，它使用 （全向）视觉感知器来获取有关其环境中对象的信息。为了检测与地面的接触和在脚部产生的力，它在每只脚上都配备了一个阻力感知器。它可以使用比赛状态感知器模拟时间，并使用陀螺仪速率感知器感知躯干的方向变化。此外，它还具有铰链关节感知器和万向关节感知器，用于感应每个关节的角度。下表是该机器人身体部件的相关信息，由于该模型已经弃用，更加详细的信息在此不再赘述。

![](D:\RoboCup\图片\2.26.png)

### 2.4.5 监视器

SimSpark 监视器负责渲染当前模拟。它连接到正在运行的服务器实例，从该实例持续接收更新流，这些更新将模拟状态描述为完整快照或增量更新。服务器发送到监视器的数据流的格式称为监视器格式，它是一种用于描述仿真状态的可自定义语言。

#### 外部监视器（rcssmonitor3d）

外部监视器实现称为 *rcssmonitor3d*，它要么连接到正在运行的 SimSpark服务器实例，要么从日志文件重放模拟运行。监视器通过键或鼠标接受许多命令。这些命令要么控制摄像机的移动，要么将命令发送回服务器以控制模拟。足球模拟使用这些命令来实现人类裁判的控制。这些快捷方式在两个设置脚本 `bindings.rb` 中配置，SimSpark `soccerbindings.rb` 监视器在启动时读取。相关使用方式在上文中仿真软件的使用中已经有所介绍。

命令选项：

```shell
  usage: rcssmonitor3d [options]

  options:
   --help  print this message.
   --logfile       logfilename     plays the log file.
   --server        server_addr     connects to the specified server.
```

连接到其他主机：

默认情况下，*rcssmonitor3d* 连接到本地主机。指定远程主机，如下所示：

```
rcssmonitor3d --server otherhostname 
```

播放日志：

修改/usr/local/share/rcssserver3d/rcssserver3d.rb文件中的相关内容：(如果采用的是软件源安装，则该文件应该位于/usr/share/rcssserver3d)

$recordLogfile = false修改为$recordLogfile = true，再启动simspark便可以记录日志文件。该日志文件将会默认保存在输入simspark命令的路径下，例如：如果在~/desktop/路径下启动simspark，则会在该路径下出现名为sparkmonitor.log的日志文件

rcssmonitor3d还可以通过指定文件名来重放录制的日志文件：

```
rcssmonitor3d --logfile logfilename.log 
```

#### RoboViz

##### 1 RoboViz的介绍

RoboViz是RoboCup 3D 足球模拟联赛的监视器和可视化工具。这是 Justin Stoecker在 SourceForge 上托管的原始版本的分支。与原始版本相比，已经进行了重大改进，展示效果要优于原始监视器，目前已经成为RoboCup 3D比赛的官方监视器。该软件主要由位于德国的奥芬堡应用科学大学（Offenburg University of Applied Sciences）的队伍magmaoffenburg团队开发，主语言为Java语言，该软件目前已开源：https://github.com/magmaOffenburg/RoboViz，除此之外，该团队还开源了他们的底层代码和很多有用的工具，该团队官网：https://magma.hs-offenburg.de/

![](D:\RoboCup\图片\2.27.png)

##### 2 RoboViz的安装

构建和运行最新版本的RoboViz 需要 Java 17，在该项目的Github上也提供了适用于 Windows、Linux 和 Mac 的预构建二进制文件，当然也可以使用项目中的scripts/build.sh或者scripts/build.bat脚本进行自行构建。

- 安装Java

  ```bash
  sudo apt update
  sudo apt install openjdk-17-jdk
  ```

- 查看Java版本

  ```bash
  java -version
  ```

  安装成功后，查看java版本将会看到如下输出：

  ![](D:\RoboCup\图片\2.28.png)

  即证明安装成功

- 下载RoboViz预构建文件

  到RoboViz项目地址（https://github.com/magmaOffenburg/RoboViz/releases）下载最新版本的RoboViz.tar.gz文件

  或者在终端中使用命令：

  ```
  wget https://github.com/magmaOffenburg/RoboViz/releases/download/2.0.0/RoboViz.tar.gz
  ```

- 解压RoboViz.tar.gz

  ```bash
  tar -zxvf RoboViz.tar.gz 
  ```

- 启动RoboViz

  解压后将会得到bin文件夹，该目录下包含linux系统下的启动文件roboviz.sh，在该目录下终端输入：

  ```bash
  bash roboviz.sh
  ```

  在终端下出现如下输出：

  ![](D:\RoboCup\图片\2.29.png)

  同时会弹出RoboViz的显示窗口，如下：

  <img src="D:\RoboCup\图片\2.30.png" style="zoom:50%;" />

  RoboViz默认的观察地址为本地的3200端口，因此在本地未开启服务器时，显示界面为上图所示。

- RoboViz测试

  在新终端中启动比赛服务器，输入：

  ```bash
  simspark #或rcssserver3d
  ```

  同时观察RoboViz将会看到球场：

  <img src="D:\RoboCup\图片\2.31.png" style="zoom:50%;" />

##### 3 RoboViz的使用

**3.1 RoboViz的命令行参数：**

| 参数             | 描述                                         |
| ---------------- | -------------------------------------------- |
| --logMode        | 以日志模式而不是实时模式启动 RoboViz         |
| --logFile=       | 立即在指定路径处打开日志文件，隐含--logMode  |
| --serverHost=    | 指定服务器的主机(覆盖config.txt中的默认主机) |
| --serverPort=    | 指定服务器的端口(覆盖config.txt中的默认端口) |
| --drawingFilter= | 绘图面板中使用的初始过滤器 - 默认值为 .*     |

使用示例：

```bash
bash roboviz.sh --logFile=sparkmonitor.log
```

使用上述命令可以读取指定的log文件并播放。

**3.2 GUI的使用**

RoboViz窗口内提供了丰富的控制操作，在窗口左侧上部包括Connection、Server、View、Camera和Help，各部分提供相应的功能。

- Connecton：该部分针对RoboViz所连接的主机和端口进行配置，默认为localhost:3200
- Server：该部分可对正在连接的服务器进行操作，如关闭服务器、修改对应的模式、重置比赛时间等，但该界面只提供了部分模式，可按下键盘‘O’，选择更多详细的比赛模式。
- View：该部分对RoboViz的显示尽心控制，例如全屏、显示绘图、显示比赛速率、显示球员编号等。
- Camear：该部分对RoboViz的镜头视角进行控制，例如跟随球、跟随指定球员、球员第一人称视角、第三人称视角等。
- Help：该部分包括RoboViz的 详细帮助文档和配置文件，在config中可以对RoboViz是否记录日志文件、文件保存位置、双方球员颜色等等。

使用RoboViz作为监视器的原因除了其展示效果较好外，其还提供了绘图工具RoboViz Draw，通过标准的消息格式发送到RoboViz，实现特定的绘图功能，便于智能体通过该工具进行调试。

在仿真界面上，可通过WASD进行视角的移动，按住鼠标左键实现视角的旋转，滚动滚轮实现视角的远近调整，空格选择视角跟随球，数字按键12345678控制不同的固定视角等其他操作。

![](D:\RoboCup\图片\2.32.png)

**3.3 修改rcsoccersim3d启动文件（可选）**

在上述对RCSSServer3D比赛软件的安装时介绍了rcsoccersim3d命令，可以同时开启simspark服务器和rcssmonitor3d外部监视器。由于目前主要使用RoboViz进行比赛的观察，可对rcsoccersim3d进行修改实现运行rcsoccersim3d命令，同时开启simspark服务器与RoboViz监视器：

- 获取roboviz.sh文件位置：

  在RoboViz的bin目录（该目录下存在roboviz.sh）下输入：

  ```
  pwd
  ```

  得到该目录的绝对路径

  ![](D:\RoboCup\图片\2.34.png)

- 查找rcsoccersim3d位置：

  ```bash
  which rcsoccersim3d
  cd /usr/local/bin
  ```

![](D:\RoboCup\图片\2.33.png)

- 修改rcsoccersim3d文件：

  在终端中输入：

  ```bash
  sudo gedit rcsoccersim3d
  ```

  将第27行处的MON="$bindir/rcssmonitor3d“修改为上述roboviz.sh的路径，即：

  ```bash
  MON="/home/robocup/RoboViz/bin/roboviz.sh"
  ```

  保存并退出，重新输入rcsoccersim3d命令可以实现同时开启simspark服务器和RoboViz监视器。

**注意**：虽然修改该文件可以方便开启服务器与监视器，但日常的开发时需要频繁的开启和关闭SimSpark服务器并且可能需要同时开启多个服务器进程，而RoboViz监视器一般仅作观察服务器仿真情况使用，无需多次开启。在实际开发过程中一般在终端中固定开启RoboVIz监视器，需要开启服务器时在新终端中使用simspark或rcssserver3d命令。

### 2.4.6 仿真更新循环

SimSpark实现了一个简单的内部事件模型，该模型会立即执行从智能体接收到的每个操作。它不会尝试补偿任何网络延迟或补偿已连接代理可用的不同计算资源。因此SimSpark目前不保证事件是可重现的，这意味着重复模拟可能会产生不同的结果，具体取决于托管代理和服务器的计算机上的网络延迟或负载变化。然而，简单结构的一个好处是速度提高，这使得它对机器学习任务很有用，因为在这些设置中，通常会重复测试大量不同的代理和模拟配置。

SimSpark 主循环是高度可定制的，因为它完全建立在我们称为 simcontrol 节点的插件之上。Simcontrol 节点已注册到仿真服务器。它们响应控制事件而行动。模拟服务器在执行抽象的主循环时重复生成这些。事件类型是模拟服务器启动时的 'init' 事件和 shutdown 时的 'done' 事件。然后，主循环在 'start cycle'、'sense agent'、'act agent' 和 'end cycle' 事件中重复循环。除了生成控制事件外，模拟服务器还会提前上一个周期中经过的模拟时间。根据其配置，它要么以离散时间量为单位，要么以一个步骤完成此操作。simcontrol 节点还可以负责时间测量，例如，将模拟时间与用于渲染场景的实时时间同步。否则，仿真将尽可能频繁地步长固定时间步长。通过这种方式，所有管理任务都作为模拟服务器的插件实现。这涉及代理管理、监视器管理、渲染、鼠标和键盘输入以及网络代码。这种设置允许我们在运行时将模拟配置为同时执行模拟和渲染的整体式应用程序，或将渲染推迟到远程监视器应用程序的专用模拟服务器。

#### 1 单线程仿真

在单线程模式下，主循环在 'start cycle'、'sense agent'、'act agent' 和 'end cycle' 事件中重复循环。

<img src="D:\RoboCup\图片\2.35.png" style="zoom:25%;" />

注意：

- 每个周期持续时间为20ms，如果仿真速度快于实时，则会等待；否则，如果模拟速度非常慢，它将运行一次许多物理更新，而无需与智能体交互。如果模拟速度很慢，它将放弃赶上实时并打印警告。因此，当计算机的运行速度不够时，您可能会遇到问题。

- 在 sense agent之后是 act agent，代理根据第 n 个周期发送的动作将在第 （n + 1） 个周期中实现，即动作已经延迟了一个周期，如下图所示。

  ![](D:\RoboCup\图片\2.36.png)

#### 2 多线程仿真

在现代计算机中具有多个 CPU 或一个 CPU 中的双核。这大大提高了性能，但只有多线程程序才能受益。SimSpark 有一个实验性的多线程运行循环，只需在spark.rb文件（文件路径/usr/local/share/simspark/spark.rb）中将 serverMultiThreadedMode赋值为true即可实现它(目前默认已经开启)。

多线程循环的实现基于两个条件。首先，仿真不同部分的每个 SimControlNode 响应，它们都在单线程模式下逐个执行，但它们可以并行运行。其次，有一个活动场景，它将整个模拟数据存储在一个树中。物理引擎和 SimControlNode 通过活动场景进行交互。众所周知，物理计算是最耗时的，物理引擎在物理计算过程中不需要访问活动场景。物理计算和 SimControlNode 可以并行运行。最后，我们得到多线程模拟循环，如下面的图所示，请注意，代理的 action 在多线程循环中也会延迟一个周期。

<img src="D:\RoboCup\图片\2.37.png" style="zoom:50%;" />

### 2.4.7 网络协议

#### 1 消息格式

来自和发送到服务器的消息使用 S-expressions（符号表达式的缩写）作为其基本数据结构。S 表达式的基本思想非常简单：它们要么是字符串，要么是更简单的 S 表达式列表。它们最出名的可能是它们在 Lisp 编程语言家族中的使用，它们用于代码和数据。

与其他数据格式相比，使用 S 表达式的一个优点是它提供了一种易于解析和紧凑的语法，在某种程度上，人类仍然可以读取该语法以进行调试。向消息添加新的传感器也很容易，因为客户端的解析器可以很容易地忽略未知部分。

客户端和服务器之间交换的消息使用默认的 ASCII 字符集，即一个字符编码为单个字节。此外，每条单独的消息都以有效负载消息的长度为前缀。length 前缀是按网络顺序排列的 32 位无符号整数，即大端表示法，首先传输最高有效位。

#### 2 服务器与智能体交流

默认情况下，服务器在 TCP 端口 3100 上向所有智能体公开网络接口，当代理连接到服务器时，代理必须首先发送创建效应器消息，然后发送初始化效应器消息。初始化后，服务器将消息组发送到智能体，其中包含智能体感知器的输出，包括机器人模型的所有铰链关节的位置、听到的任何消息、看到的对象等。发送的具体消息取决于为智能体创建的机器人模型。为了响应这些感知器消息，智能体可以通过发送效应器消息来影响模拟。服务器通过这些消息执行任务，例如在仿真中转动关节。详细的消息格式在上文有关感知器和效应器的有关内容已经介绍过。

#### 3 服务器与监视器交流

默认情况下，服务器在 TCP 端口 3200 上向任何监视器公开网络接口。此接口允许定期通知外部进程模拟的状态，以便进行可视化、日志记录等。此外，连接的进程可能会向服务器发送各种命令，例如修改比赛的模式，移动球或球员的位置，具体的信息将在下文介绍，这些可用于训练或机器学习。但是这些命令不能直接提供给智能体，在RoboCup足球比赛模拟期间也不允许使用。

当监控器使用监控器协议连接到 Simspark 服务器时，信息按以下顺序到达：

- 服务器发送环境信息消息，后跟完整的场景图。
- 服务器发送游戏状态消息，后跟完整的场景图。
- 服务器会不断发送部分游戏状态消息，后跟完整或部分场景图，具体取决于最近更新的内容。服务器通过监视端口发送消息的速率在spark.rb（/usr/local/share/simspark/spark.rb）中定义。

#### 4 环境信息消息

环境信息消息具有以下结构：

```
((<EnvironmentInformation>)(<SceneGraphHeader>)(<SceneGraph>)) 
```

以下是rcssserver3d提供的该EnvironmentInformation部分的示例：

```plaintext
((FieldLength 18)(FieldWidth 12)(FieldHeight 40)
 (GoalWidth 2.1)(GoalDepth 0.6)(GoalHeight 0.8)
 (FreeKickDistance 1.3)(WaitBeforeKickOff 2)
 (AgentRadius 0.4)(BallRadius 0.042)(BallMass 0.026)
 (RuleGoalPauseTime 3)(RuleKickInPauseTime 1)(RuleHalfTime 300)
 (play_modes BeforeKickOff KickOff_Left KickOff_Right PlayOn
             KickIn_Left KickIn_Right corner_kick_left corner_kick_right
             goal_kick_left goal_kick_right offside_left offside_right
             GameOver Goal_Left Goal_Right free_kick_left free_kick_right)
)
```

初始化表达式的每个子表达式都是一个名字-值对，它给出当前模拟实例使用的一个参数。不同参数的含义：

- **FieldLength**、**FieldWidth**、**FieldHeight** ：足球场的尺寸（以米为单位）
- **GoalWidth**、**GoalDepth**、**GoalHeight**：球门的尺寸（以米为单位）
- **FreeKickDistance**：当球员执行任意球时对方球员必须保持的距离（以米为单位）
- **WaitBeforeKickOff**：给出服务器在自动启动游戏之前等待的时间（以秒为单位）
- **AgentRadius**：每个代理的半径（以米为单位）
- **BallRadius**：球的半径（以米为单位）
- **BallMass**：球的质量（以千克为单位）
- **RuleGoalPauseTime**：服务器在进球后切换到开球模式之前等待的时间（以秒为单位）
- **RuleKickInPauseTime** ：在比赛模式下，球离开场地后，服务器在切换到踢球之前等待的时间（以秒为单位）
- **RuleHalfTime**：半场时长（以秒为单位）
- **play_modes**：列出了足球比赛的不同比赛模式，之后，比赛模式由从零开始的索引引用到此列表中。

#### 5 比赛状态消息

比赛状态消息具有以下结构：

```
[GameState] [SceneGraphHeader] [SceneGraph] 
```

以下是比赛状态消息的部分示例：

```
((time 0)(half 1)(score_left 0)(score_right 0)(play_mode 0)) 
```

比赛模式是一个整数，它表示在上述环境消息中枚举定义的比赛类型。

#### 6 场景图标头

场景图标头包含有关场景图完整性和版本号的信息，并具有以下格式：

```
(Name Version Subversion) 
```

- **Name**可以采用两个值：
  - **RSG**代表 Ruby Scene Graph，表示场景图是环境的完整描述。
  - **RDS**代表 Ruby Diff Scene，表示场景图是对环境的部分描述，即它包含一堆代表场景图结构的空节点，以及有关最近更改的节点的一些更新信息。
- **Version**：场景图的主版本号。
- **Subversion**：场景图的子版本号。

例如：

- `(RSG 0 1)` 表示完整场景图，版本 0.1

- `(RDS 0 1)` 指示部分场景图，版本 0.1

在以下两种情况下，会生成完整状态消息：

1. 当新客户端连接
2. 添加或删除一个或多个节点（例如，在场景导入、代理连接/断开连接等时）

#### 7 场景图内容

场景图是一种结构，用于安排图形场景的逻辑和空间表示。在 Simspark 中，场景图是一棵树，其根节点定义为位于原点 <0;0;0> 无旋转。每个节点都有一个或多个子节点，每个子节点的位置和旋转是从根节点到子节点的转换矩阵的乘积。

当前的监视器协议是图形RubySceneGraph场景描述语言的简化版本。它由几个缩写组成，而不是完整的节点名称，这样做是为了节省带宽。

可以打开上文内容中所记录的sparkmonitor.log日志文件，可以看到类似余下述内容：

(RSG 0 1)((nd TRF (SLT 1 0 0 0 0 1 0 0 0 0 1 0 -10 10 10 1)(nd Light (setDiffuse 1 1 1 1) (setAmbient 0.8 0.8 0.8 1) (setSpecular 0.1 0.1 0.1 1)))(nd TRF (SLT 1 0 0 0 0 1 0 0 0 0 1 0 10 -10 10 1)(nd Light (setDiffuse 1 1 1 1) (setAmbient 0 0 0 1) (setSpecular 0.1 0.1 0.1 1)))(nd TRF (SLT -1 -8.74228e-08 -3.82137e-15 0 0 -4.37114e-08 1 0 -8.74228e-08 1 4.37114e-08 -0 0 0 0 1)(nd StaticMesh (setVisible 1) 

由于该部分主要针对场景的描述进行构建渲染，主要帮助可视化软件开发人员有所帮助，因此关于更多的信息在此不在赘述，更加详细的信息可在https://gitlab.com/robocup-sim/SimSpark/-/wikis/Network-Protocol查看。

#### 8 教练/训练命令

人类裁判可以在比赛期间使用监视器（例如RoboViz）来执行比赛当前未满足的比赛规则。此外，训练过程可能需要发送命令，以特殊方式影响环境，以提高学习练习的速度或质量。请注意，在某些比赛模式中，发送命令可能不起作用。例如，在BeforeKickOff模式下将球从中心位置移开会立即被服务器抵消。下述是相关的一些命令：

**移动智能体**

您可以移动智能体，也可以移动和轮换智能体，此外，您还可以设置电池电量和温度。

```plaintext
(agent (unum <num>) (team <team>) (pos <x> <y> <z>)
                                  (move <x> <y> <z> <rot>)
                                  (battery <batterylevel>)
                                  (temperature <temperature>)
)
```

相关参数：

- <team> ：两边的队伍（left或right中的一个）
- <unum>：球员的编号
- <x><y><z>：球员坐标的位置（0,0)为球场正中心

**移动球**

球可以重新定位，也可以选择给定明确的速度：

```plaintext
(ball (pos <x> <y> <z>)
      (vel <x> <y> <z>)
)
```

`pos` 为球的目标位置和 `vel`为球的速度，两者都是可选的。但如果两者都不包含，则不会进行任何更改。注意，设置球的速度也会将球的任何角速度重置为零。

**设置比赛模式**

比赛模式可以手动设置为指定的值：

```
(playMode <playmode>) 
```

其中 `<playmode>` 是预定义的、区分大小写的比赛模式值之一。可能的播放模式在监视器连接时接收的初始化表达式的 `play_modes` 表达式中以字符串形式给出。

**抛球**

将球抛到当前位置，并将所有球员移动任意球半径。如果球离开球场，则将其带回界内：

```
(dropBall) 
```

该命令主要用于当多个机器人争夺球导致所有机器人都无法接触到球时的情况，以维持比赛的正常进行。

**开球**

将足球开球分配给指定的球队：

```
(kickOff <team>) 
```

其中<team> 是 Left, Right, None中的一个，如果选择None，则应该通过抛硬币以选择一支球队。

**选择代理**

```
(select (unum <num>) (team <team>)) 
```

其中<team> 是Left, Right, None中的一个，如果unum或者team未指定，则选择下一个智能体，并且一次只能选择一个智能体。

**删除代理**

从比赛中删除指定的代理：

```
(kill (unum <num>) (team <team>)) 
```

其中<team>是 Left, Right, None中的一个，如果未指定unum或者team，则会删除选择的代理。

**设置时间**

设置比赛时间：

```
(time <time>) 
```

**设置比赛分数**

设置比赛的分数：

```
(score (left <score>) (right <score>)) 
```

**请求完整状态消息**

从服务器请求完整场景更新消息：

```
(reqfullstate)
```

## 2.5 RoboCup仿真3D项目底层代码介绍

通过上述对比赛概念的介绍，可以了解到与仿真服务器的通讯主要依靠网络通信，并按照一定的格式规定标准消息流，从而实现了便捷的仿真开发。然而，从基础消息解析与发送开始从头构建一个比赛球队所需要巨大的工作量，主要包括机器人的步态引擎、世界模型的构建、行为动作的设计与优化，以及团队间的高层交流合作等，这些方面需要大量的开发工作。幸运的是，在参加历年RoboCup3D比赛的队伍中，有不少队伍将他们开发的底层代码开源了出来，提供给相关科研人员和比赛队伍使用。主要包括了基础的消息解析与打包，特定的机器人引擎，机器人姿态估计，基本行为动作，基本团队交流等，使得采用底层的人员能够关注机器人步态的调整与优化，高级动作设计，高级团队策略等方面的研究，大大节省了开发时间，本节将对主要的开源底层进行介绍。

### 2.5.1 UT Austin Villa 3D

官方开源网址：https://github.com/LARG/utaustinvilla3d

该代码由美国的德克萨斯大学奥斯汀分校的UT Austin Villa团队开发，该团队于 2007 年首次参加 RoboCup 3D 模拟联赛。在近十年的时间里，该团队已经建立了强大的最先进的代码库，使团队赢得了很多比赛，分别在2011, 2012, 2014, 2015, 2016, 2017, 2018, 2019, 2021年举办的RoboCup世界杯中的仿真3D联赛冠军， 是目前在所有参与RoboCup仿真3D比赛队伍中赢得冠军最多的队伍。在RoboCup仿真3D比赛中新队伍很难与老队伍竞争，因为 RoboCup仿真3D比赛环境的复杂性导致新队伍加入比赛的门槛往往高于预期，为了给新球队提供一个良好的起点，该团队在2015年获得冠军后发布了该团队使用的底层代码，主要语言为C/C++，但是删去了部分高级策略和团队决策。

该代码的主要包括：

- 基于双倒立摆模型的全向行走引擎
- 一种用于指定参数化技能/行为的技能描述语言
-  适用于所有机器人类型的起身行为
- 用于踢球的基本动作（部分使用了逆运动学）
- 用于进球的演示带球和踢球行为
- 用于定位的粒子滤波器和世界模型
- 用于跟踪对象的卡尔曼滤波器
- 从服务器发送/接收消息的解析代码
- 在 RoboViz监视器中绘制对象的代码
- 为团队球员提供的通信系统
- 用于优化踢球的示例行为/任务
- 具有基本阵型和动态贪婪角色分配的简单足球行为示例

团队代码运行架构：

![](D:\RoboCup\图片\2.38.jpeg)

除此之外，该团队还针对其底层代码发布了相应的讲解视频：https://www.youtube.com/watch?v=5-8YFmJlqhk

### 2.5.2 magmaOffenburg

官方开源地址：https://github.com/magmaOffenburg/magmaRelease

该代码由德国的奥芬堡应用科学大学的magmaOffenburg团队开发，自2009年以来，奥芬堡大学开始教授模拟机器人踢足球。 使用3D Nao机器人在众多国际比赛中与来自世界各地其他大学和学院的团队进行竞争。克劳斯·多雷尔 (Klaus Dorer) 教授带领的团队已经多次获奖，在机器人世界杯上多次获得了世界锦标赛亚军的称号。该团队在2021年发布了他们团队开发的底层代码，主要使用Java语言，该底层架构如下：

<img src="D:\RoboCup\图片\2.39.jpg" style="zoom: 50%;" />

除底层代码外，该团队还对他们开发的底层发布了一个讲解视频，能够帮助新成员快速了解和上手该项目：https://www.youtube.com/watch?v=_FNaMjJlNfI

### 2.5.3 FC Portugal

官方开源地址：https://github.com/m-abr/FCPCodebase

该代码由葡萄牙的波尔图大学的FC Portugal团队开发，该团队拥有悠久的历史，并为比赛团队做出了很多贡献。该团队是近几年世界杯冠军的获得者，尤其2021 之后，该团队决定用 Python 从头开始重建所有代码（除一些高密集计算模块使用C++），并在该年发布了此底层。FC Portugal是RoboCup仿真3D比赛中首支使用了深度强化学习技术控制机器人学习高级动作的队伍，是联赛中首支实现快速跑步的队伍，也是目前开源代码中基础能力最高的底层代码，同时python语言的易读性和丰富的开发包也大大降低了对其进行二次开发的难度。该底层主要包括：

- 基于概率的6D位姿估计算法和IMU精确定位
- 自动头部定向
- 与队友自动通信，共享所有可见球员和球的位置
- 基础库：常用数学运算、服务器通信、RoboViz 绘图（带箭头和预设颜色）
- 必要时在内部重置技能的行为管理器
- 用于生成二进制文件的 Bundle 脚本和相应的 start/kill 脚本
- 使用 C++ 语言实现自定义 A* 寻路，并针对足球环境进行了优化
- 轻松集成基于神经网络的行为
- 与Open AI Gym 集成，通过强化学习训练模型
- 移动球位置和速度的预测器
- 通过前向运动学和视觉确定每个身体部位和关节的相对/绝对位置和方向

底层运行架构：

![](D:\RoboCup\图片\2.40.webp)

该团队还提供了相关的文档手册提供参考：https://docs.google.com/document/d/1aJhwK2iJtU-ri_2JOB8iYvxzbPskJ8kbk_4rb3IK3yc/edit

相关参考：

[干货 | 浅谈机器人仿真平台-CSDN博客](https://blog.csdn.net/pengzhouzhou/article/details/131427681)

[什么是机器人仿真？ - MATLAB & Simulink](https://ww2.mathworks.cn/discovery/robot-simulation.html)

[rcssserver3d: Implementation of the Soccer Playing Spheres](https://robocup-sim.gitlab.io/SimSpark/doc/rcssserver3d/spheres_implementation.html)